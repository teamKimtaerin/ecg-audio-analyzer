# ECG Audio Analyzer - Continuous Deployment
# Automated deployment to AWS EC2 g4dn.xlarge with GPU optimization
name: CD - Production Deployment

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'examples/**'
      - 'assets/**'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment (skip some checks)'
        required: false
        default: false
        type: boolean
      target_instance:
        description: 'Target EC2 instance type'
        required: false
        default: 'g4dn.xlarge'
        type: choice
        options:
          - 'g4dn.xlarge'
          - 'g4dn.2xlarge'
          - 'p3.2xlarge'

# Security: Ensure only one deployment at a time
concurrency:
  group: production-deployment
  cancel-in-progress: false

env:
  # Application configuration
  APP_NAME: ecg-audio-analyzer
  DOCKER_IMAGE: ecg-audio-analyzer:latest
  CONTAINER_NAME: ecg-audio-analyzer
  
  # AWS Configuration
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
  
  # Deployment configuration
  DEPLOYMENT_TIMEOUT: 600  # 10 minutes
  HEALTH_CHECK_TIMEOUT: 180  # 3 minutes

jobs:
  # =============================================================================
  # Pre-deployment Validation
  # =============================================================================
  pre-deployment-checks:
    name: üîç Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.changes.outputs.should_deploy }}
      version: ${{ steps.version.outputs.version }}
      
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üîç Check for significant changes
        id: changes
        run: |
          # Check if we should skip deployment
          if [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "üöÄ Force deployment requested"
            exit 0
          fi
          
          # Check for code changes (not just docs/readme)
          if git diff --name-only HEAD~1 | grep -E '\.(py|yml|yaml|toml|txt|sh)$'; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Code changes detected, deployment needed"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No significant code changes, skipping deployment"
          fi

      - name: üìù Generate version tag
        id: version
        run: |
          # Generate version from timestamp and commit SHA
          VERSION="v$(date +'%Y%m%d')-$(git rev-parse --short HEAD)"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è Generated version: $VERSION"

  # =============================================================================
  # Build and Push Docker Image
  # =============================================================================
  build-and-push:
    name: üèóÔ∏è Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks]
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true'
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üîë Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: üè∑Ô∏è Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ECR_REGISTRY }}/${{ env.APP_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ needs.pre-deployment-checks.outputs.version }}

      - name: üèóÔ∏è Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile.gpu
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}

      - name: üîç Image security scan (non-blocking)
        continue-on-error: true
        run: |
          # Install trivy for container scanning
          sudo apt-get update
          sudo apt-get install -y wget
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy
          
          # Scan the pushed image
          trivy image --exit-code 0 --severity HIGH,CRITICAL ${{ env.ECR_REGISTRY }}/${{ env.APP_NAME }}:latest

  # =============================================================================
  # Deploy to EC2 Instance
  # =============================================================================
  deploy-to-ec2:
    name: üöÄ Deploy to EC2
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-push]
    environment: production
    
    steps:
      - name: üì• Checkout deployment scripts
        uses: actions/checkout@v4

      - name: üîê Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üîë Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: üìä Check EC2 instance status
        run: |
          # Check if instance is running
          INSTANCE_STATE=$(aws ec2 describe-instances \
            --instance-ids ${{ env.EC2_INSTANCE_ID }} \
            --query 'Reservations[0].Instances[0].State.Name' \
            --output text)
          
          echo "üñ•Ô∏è Instance state: $INSTANCE_STATE"
          
          if [[ "$INSTANCE_STATE" != "running" ]]; then
            echo "‚ùå Instance is not running. Current state: $INSTANCE_STATE"
            exit 1
          fi

      - name: üßπ Cleanup old containers and images
        run: |
          ssh -o StrictHostKeyChecking=no ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            echo "üßπ Cleaning up old containers and images..."
            
            # Stop and remove existing container
            if docker ps -q --filter "name=${{ env.CONTAINER_NAME }}" | grep -q .; then
              echo "Stopping existing container..."
              docker stop ${{ env.CONTAINER_NAME }} || true
              docker rm ${{ env.CONTAINER_NAME }} || true
            fi
            
            # Remove old images (keep last 3)
            echo "Cleaning up old Docker images..."
            docker image prune -f
            
            # Check disk space
            echo "üíæ Disk usage after cleanup:"
            df -h /
          EOF

      - name: üîë Login to ECR on EC2
        run: |
          ssh -o StrictHostKeyChecking=no ubuntu@${{ secrets.EC2_HOST }} << EOF
            # Configure AWS CLI with credentials
            aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws configure set default.region ${{ env.AWS_REGION }}
            
            # Login to ECR
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
              docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
          EOF

      - name: üì¶ Pull latest Docker image
        run: |
          ssh -o StrictHostKeyChecking=no ubuntu@${{ secrets.EC2_HOST }} << EOF
            echo "üì¶ Pulling latest Docker image..."
            docker pull ${{ env.ECR_REGISTRY }}/${{ env.APP_NAME }}:latest
            
            echo "üè∑Ô∏è Tagging image as current deployment..."
            docker tag ${{ env.ECR_REGISTRY }}/${{ env.APP_NAME }}:latest ecg-audio-analyzer:gpu
          EOF

      - name: üöÄ Deploy application with docker-compose
        timeout-minutes: 10
        run: |
          ssh -o StrictHostKeyChecking=no ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            cd /opt/ecg-audio-analyzer
            
            echo "üöÄ Starting deployment with docker-compose..."
            
            # Create environment file
            cat > .env << ENV_EOF
            INSTANCE_TYPE=g4dn.xlarge
            INSTANCE_ID=${{ env.EC2_INSTANCE_ID }}
            AWS_DEFAULT_REGION=${{ env.AWS_REGION }}
            ECG_S3_BUCKET=${{ secrets.S3_BUCKET_NAME }}
            AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            ENVIRONMENT=production
            LOG_LEVEL=INFO
            ENV_EOF
            
            # Deploy with docker-compose
            docker-compose -f docker-compose.aws.yml up -d --remove-orphans
            
            echo "‚úÖ Deployment started successfully"
          EOF

      - name: üè• Health check
        timeout-minutes: 3
        run: |
          echo "üè• Performing health check..."
          
          # Wait for container to be fully ready
          for i in {1..18}; do
            if ssh -o StrictHostKeyChecking=no ubuntu@${{ secrets.EC2_HOST }} \
               "docker exec ${{ env.CONTAINER_NAME }} /usr/local/bin/healthcheck.sh"; then
              echo "‚úÖ Health check passed!"
              break
            fi
            
            if [ $i -eq 18 ]; then
              echo "‚ùå Health check failed after 3 minutes"
              # Get container logs for debugging
              ssh -o StrictHostKeyChecking=no ubuntu@${{ secrets.EC2_HOST }} \
                "docker logs --tail 50 ${{ env.CONTAINER_NAME }}"
              exit 1
            fi
            
            echo "‚è≥ Waiting for application to be ready... (attempt $i/18)"
            sleep 10
          done

      - name: üìä Post-deployment validation
        run: |
          ssh -o StrictHostKeyChecking=no ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            echo "üìä Post-deployment system status:"
            
            # Container status
            echo "üê≥ Container status:"
            docker ps --filter "name=${{ env.CONTAINER_NAME }}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # GPU status
            echo "üéÆ GPU status:"
            nvidia-smi --query-gpu=name,utilization.gpu,memory.used,memory.total --format=csv,noheader
            
            # System resources
            echo "üíª System resources:"
            echo "CPU: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)% usage"
            echo "Memory: $(free -h | awk 'NR==2{printf "%.1f%%", $3*100/$2 }')"
            echo "Disk: $(df -h / | awk 'NR==2{print $5}')"
            
            # Application logs (last 10 lines)
            echo "üìã Recent application logs:"
            docker logs --tail 10 ${{ env.CONTAINER_NAME }}
          EOF

  # =============================================================================
  # Deployment Notification and Rollback
  # =============================================================================
  post-deployment:
    name: üì¢ Post-deployment Actions
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-push, deploy-to-ec2]
    if: always()
    
    steps:
      - name: üìä Deployment Summary
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: ${{ needs.pre-deployment-checks.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target**: AWS EC2 g4dn.xlarge" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Time**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.deploy-to-ec2.result }}" == "success" ]]; then
            echo "‚úÖ **Status**: Deployment Successful" >> $GITHUB_STEP_SUMMARY
            echo "üîó **Application**: https://${{ secrets.EC2_HOST }}:8080" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Status**: Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "üîÑ **Action**: Check logs and consider rollback" >> $GITHUB_STEP_SUMMARY
          fi

      - name: üö® Rollback on failure
        if: needs.deploy-to-ec2.result == 'failure'
        run: |
          echo "üö® Deployment failed, initiating rollback..."
          # In a real scenario, you would implement rollback logic here
          echo "‚ö†Ô∏è Manual intervention required for rollback"

      - name: ‚úÖ Success notification
        if: needs.deploy-to-ec2.result == 'success'
        run: |
          echo "üéâ Deployment completed successfully!"
          echo "üîó Application is now running at: https://${{ secrets.EC2_HOST }}:8080"
          echo "üìä Monitor the application performance and logs"